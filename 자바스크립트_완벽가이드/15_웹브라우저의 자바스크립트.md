
|  | 정보 |
|---|---|
| date | 2022-07-20 |
| group | FEOnTheBlock |
| link | [[완벽가이드] ...](#) |

1회차: 15~15.3 (465p ~ 513p)
2회차:
3회차:

> 이 장은 **웹 플랫폼의 프로그래밍 모델**에 대해 설명한다.
-  15.1: HTML 페이지에 스크립트를 불러오는 방법
-  15.2: 이벤트를 통해 JS 코드를 비동기적으로 실행하는 방법
-  15.3: 문서 콘텐츠 제어
-  15.4: 스타일 제어
-  15.5: 문서 요소의 화면 위치 판단
-  15.6: 재사용할 수 있는 사용자 인터페이스 구성 요소 생성
-  15.7, 15.8: 그래픽
-  15.9: 사운드 생성과 재생
-  15.10: 브라우저 내비게이션과 히스토리 관리
-  15.11: 네트워크를 통한 데이터 교환
-  15.12: 사용자의 컴퓨터에 데이터 저장
-  15.13: 스레드를 사용한 병렬 계산


**구형 API란?**
- 특정 브라우저 제조사에서만 사용되는 전용 API
- 새로운 API로 대체된지 오래된 API (스타일 관련 등)
- 더 좋은 API로 대체된 저품질의 API (문서 객체 모델 등)
- document.wirte() 성능에 심각한 영향을 주므로 사용 금지

## 15.1 웹 프로그래밍 기본
웹에서 자바스크립트 프로그램을 구성하는 방법
	`<script>` 태그를 이용해 html에서 js를 불러 옴


**모듈**
 js 프로그램을 모듈로 작성했으면서 번들링 도구로 모듈을 하나의 자바스크립트 파일로 조합하지 않았다면 반드시 최상위 모듈을 `<script type="module">` 태그로 불러와야 한다.

 `type="module"`
- 지정한 모듈을 불러온다
- 그 모듈에서 가져오는 import 모듈을 보두 불러온다.
- (재귀적으로) 다시 가져온 모듈을 불러온다.
- defer 속성이 있는 것 처럼 실행

> 리액트 등 프레임워크를 사용하면 번들링되었기 때문에 module 타입을 지정할 필요가 없는 것(?)

즉, type을 사용하는 경우는 스크립트가 모듈이거나 웹 페이지에 데이터를 가져오지만 표시하지는 않을 때 뿐이다(`15.3.4절 참고 ???`)
	- type="application/javascript" 는 웹 초기에 혹시나 js말고 다른 것 사용할까 봐 넣었던 것. 지금은 필요 없음


**스크립트 실행 시점: async, defer**
- bool 속성
- src와 함께 사용해야 의미가 있다.
- defer: 문서를 파싱이 끝날 때 까지 스크립트 실행을 지연(defer)
- async: 스크립트를 가능한 빨리 실행하되 스크립트를 내려받는 동안은 문서 파싱 허용
- 우선순위: async > defer


**필요에 따른 스크립트 로드**
모듈을 쓰지 않는다면 필요에 따라 스크립트 태그를 헤드에 추가`(쓸 일이 있을까???)`
```js
// 지정된 URL에서 비동기적으로 스크립트를 불러와서 실행합니다. 
// 스크립트를 불러오면 해석되는 프라미스를 반환합니다. 
function importScript(url) { 
	return new Promise((resolve, reject) => { 
	let s = document.createElement("script"); // <script>요소 생성
	s.onload = () => {resolve(); };
	s.onerror = (e) => {reject(e); };
	s.src = url;
	document.head.append(s); // 문서에 <script> 추가
```


### 15.1.2 문서 객체 모델 Document
> HTML 문서를 다루는  API
> DOM(Document Object Model)

- Document, Text, Element 클래스는 Node 클래스의 서브클래스이며 Node 객체는 트리 구조로 되어 있어, js에서 DOM API를 사용해 검색하고 이동할 수 있다.
- parent, children, sibling, descendant, ancestor
- 각 HTML 태그 타입에 대응하는 js 클래스가 있고 문서에 존재하는 각 태그는 클래스의 인스턴스로 표현된다. 요소 클래스는 태그 속성을 반영하고 (src ... ) 추가로 메서드를 정의(HTMLVideoElement 클래스의 play(), pause())하기도 한다.



### 15.1.3 웹 브라우저의 전역 객체
> 탭마다 이에 대응하는 전역 객체가 하나씩 있다.

- 워커스레드를 제외한 모든 자바스크립트 코드가 이 전역 객체를 공유한다.
- js 표준 라이브러리는 전역 객체에 정의된다.
- 전역 객체의 임무
	- 내장 타입과 함수 정의
	- 현재 브라우저의 history, innerWidth 등 브라우저에 대한 정보를 나타낸다.

> Vue 에서  뷰 전역 객체에 라이브러리나 공통 값 넣어주는 방법 더 알아보면 좋을 듯 `(????)`


### 15.1.4 네임스페이스를 공유하는 스크립트
모듈은 모듈 스코프를 가진다.
또한 최상위에 선언해도 (js는 전역 객체에 프로퍼티로 생성되는데 반해) '공유된 네임스페이스' 안에 생성된다.

### 15.1.5 자바스크립트 프로그램 실행
문서에 존재하거나 문서를 참조하는 자바스크립트 코드가 모여 자바스크립트 프로그램이 된다.

웹 페이지에 `<iframe>`요소로 임베드된 프레임이 있다면 그 문서의  js코드는 임베드한 문서와는 다른  전역 객체와 Document 객체를 가지므로 별도의  js프로그램이라고 볼 수 있다.
같은 서버에서 불러왔다면 각 문서의 코드가 상호작용할 수 있다.

(그럼 하나의 브라우저 탭 안에 두 개 이상의 전역 객체와 DOM을 가질 수 있다는 말 `???475p`)

**js 실행 단계**
- 스텝1: 문서 콘텐츠 불러오고 `<script>` 요소 코드 실행 (동기적) 
- 스텝2: 비동기적이며 이벤트 주도적
	- 1 단계에서 하나 이상의 이벤트 핸들러나 콜백 함수 등록 해야 2단계로 넘어 옴.


**클라이언트 사이드 js 스레드 모델**
- js는 싱글 스레드이기 때문에 스크립트와 이벤트 핸들러가 너무 오래 실행되게 만들어서는 안된다.
=> `웹 워커`를 통해 동시성을 구현한다.

> **웹 워커란?**
> 
> - 사용자 인터페이스를 멈추지 않으면서 실행되는 **백그라운드 스레드**
> - 문서 콘텐츠에 접근할 수 **없다**.
> - 메인 스레드나 다른 워커와는 상태를 공유하지 않으면서 **오로지 비동기 메시지 이벤트를 통해서만 통신**한다.
> 	- 메인 스레드가 이런 동시성을 인지하지 못하기 때문에 웹 워커는  js 의 싱글 스레드 실행 모델을 망치지 않는다.
> 	- `15.13에서 더 알아본다.`


**클라이언트 사이드 자바스크립트 타임라인**
1. 웹 브라우저가 Document 객체 생성, 웹 페이지를 분석하며 엘리먼트 객체와 텍스트 노드를 문서에 추가. `document.readyState = 'loading'`
2. `<script>` 를 만나면(async, defer, type='module'인 경우 제외) 스크립트 태그를 문서에 추가하고 스크립트 분석 및 실행. HTML 파싱 중단
3. async: 스크립트 텍스트를 내려받다가 다 받으면 실행
4. 문서 분석이 끝나면 `document.readyState='interactive'`로 바뀐다.
5. defer, module: 문서 순서대로 실행된다.Document 전체에 접근 가능
6. DOMContentLoaded 이벤트 발생 => step2로 전환
	1. 이 시점에 실행되지 않은 async 스크립트가 있을 수 있다`?해석이 덜 끝나서?(478p)`
7. 모든 이미지 등 용량이 큰 콘텐츠의 로딩과 async 스크립트 실행도 끝나면 `document.readyState='complete'`
	1. Window 객체에서 load 이벤트 발생
8. 사용자 입력 이벤트, 네트워크 이벤트, 타이머 종료 등에 의해 이벤트 핸들러가 비동기적으로 호출된다.




### 15.1.6 프로그램 입출력

- DOM API를 통해 직접 접근
- 이벤트 형태 사용자 입력(버튼, 인풋 등)
- document.URL
- document.cookie
- 전역 navigator: 웹 브라우저, 운영 체제과 그 기능에 접근
	- navigator.userAgent 웹 브라우저를 식별하는 문자열
	- navigator.language 사용자가 선호하는 언어
	- navigator.hardwareConcurrency 웹 브라우저가 사용할 수 있는  `논리적 CPU???(479p)` 개수
- 전역 screen 프로퍼티: 디스플레이 관련 정보
- navigator, screen 객체를 노드 프로그램의 환경 변수라고 생각해도 됨.



### 15.1.7 프로그램 에러
js 프로그램이 실행되는 동안 예외가 발생하고 이를 처리할 catch문이 없다면 콘솔에 에러메시지가 표시될 뿐 등록된 핸들러는 계속 실행되며 반응한다.

Window.onerror 프로퍼티에 에러 핸들러 함수를 정의하면 처리하지 않은 예외가 콘솔에 메시지를 표시하는 타이밍에 `window.onerror(errMsg, 에러 발생 코드 URL, 에러 발생 위치 행)` 함수가 실행된다. 이 함수가  TRUE를 반환하면 부라우저에 에러메시지가 나오는 등의 다른 에러 처리를 하지 않는다.

프라미스의  .catch()가 없다면 처리하지 않은 예외가 있는 것과 비슷
window.onunhandlerejection 에 함수 정의 혹은 window.addEventListener()로 핸들러 등록
위 핸들러에 전달되는 이벤트 객체 promise 프로퍼티에 rejected된 값이 있다. reason  프로퍼티에서 .catch() 함수에 전달된 것을 값다.

잘 쓸 일은 없지만 fetch() 함수 등을 사용할 때 예상치 못한 에러를 서버에 보고하는 매커니즘 등에 유용할 수 있다.


### 15.1.8 웹 보안 모델

**(클라이언트 사이드에서) 자바스크립트에서 할 수 없는 일**
- 클라이언트 컴퓨터의 디렉터리를 읽을 수 없다. 파일을 수정하거나 삭제할 수 없다.
- 범용 네트워크 기능이 없다. `?? 481p`
범용 인터넷 클라이언트와 서버를 만들 수는 없다.

**동일 출처 정책(same-origin-policy)**
- 스크립트는 **자신을 포함한 문서**와 **같은 서버**에서 가져온 창과 문서의 프로퍼티만 읽을 수 있다.
- 출처 정의 방식 : URL의 프로토콜, 호스트, 포트
	-` 481p 같은 서버 에서 하나 이상의 문서를 가져와 표시하는 프로그램을 만들고 있다면 로컬에서 file: URl로는 테스트할 수 없고 개발 과정에 정적 웹 서버를 사용해야 합 니다.`
- CORS로 허용된 웹 서버는 읽을 수 있음
	- HTTP를 Origin: 요청 헤더와 Access-Control-Allow-Origin 응답 헤더로 확장한다.

**교차 사이트 스크립트(Cross-site scripting)(XSS)**
공격자가 HTML 태그나 스크립트를 주입. 사용자가 전송한 데이터에서 HTML 태그를 제거하는 sanitize가 없으면 보안에 취약하다. ???

(꾸벅)



## 15.2 이벤트

**이벤트 타입**
mousemove, keydown 등 이벤트 종류를 지정하는 문자열

이벤트 대상
Window, Document, Element 객체. 혹은 Worker 객체

**이벤트 핸들러(이벤트 리스너)**
이벤트를 처리하거나 반응하는 함수

**이벤트 객체**
특정 이벤트와 연관되며 해당 이벤트에 관한 세부 정보를 포함. type, target, currentTarget 등의 프로퍼티가 있음

**이벤트 전달**
캡처, 버블링


### 15.2.1 이벤트 범주
- 장치 의존적인 입력 이벤트
	- mousedown, mousemove, tochstart...
- 장치 독립적인 입력 이벤트
	- click, input ...
- 사용자 인터페이스 이벤트
	- 고수준 이벤트로 form 요소에서 자주 사용 됨. focus, change, submit...
- 상태 전환 이벤트
	- load, DOMContentLoaded 등 브라우저나 네트워크 활동에 의해 발생
- API 전용 이벤트
	- video, audio 등의 요소에서 미디어 제어

### 15.2.2 이벤트 핸들러 등록
- 프로퍼티 설정
	- `form.onsubmit = () => {}`
	- 자바스크립트 내부에서 with문을 사용해 해당 요소가 포함된 문서 객체를 스코프에 존재하는 것 처럼 직접 참조할 수 있다. 이는 혼란스러운 버그를 유발할 수 있다.
		- (예시 코드???)
	- HTML에 이벤트 핸들러를 작성하지 않는다.
- addEventListner 로 핸들러 전달
	- Window, Document, Element 객체가 대상이 될 수 있다.
	- 같은 객체의 같은 이벤트 타입에 하나 이상의 핸들러 함수를 등록할 수 있다.
	- 파라미터: 이벤트, 핸들러, {capture:true, once: false, passive: true}
	- `passive ??` (492p)

### 15.2.3 이벤트 핸들러 호출

- 이벤트 객체
	- target: 이벤트가 일어난 객체
	- currentTarget: 현재 이벤트 핸들러가 등록된 객체
- 이벤트 핸들러 컨텍스트
	- this: 이벤트 핸들러가 등록된 객체 (화살표 함수 제외)
- 핸들러 반환 값
	- 아무것도 반환하면 안됨
- 호출 순서
	- 프로퍼티 등록과 이벤트 핸들러가 섞여 있어도 순서를 지켜서 호출 됨


### 15.2.4 이벤트 전달
대부분의 요소는 버블링을 통해 거슬러 올라감
	- focus, blur, scroll 제외
	- load는 버블링 일어나지만 Document에서 멈춤
	- Window 객체의 load 핸들러는 문서 전제의 로딩이 끝났을 때만 호출

### 15.2.5 이벤트 취소
- preventDefault()
	- 단, passive 옵션 사용시 무력화
- stopPropagation()
	- 같은 객체에 대른 핸들러는 호출되지만 다른 객체의 이벤트 핸들러는 호출되지 않는다.(496p) `다른 객체면 같은 요소에 적용된 다른 타입의 이벤트 객체??`
- stopImmediatePropagation()
	- 같은 객체에 후순위로 등록된 나머지 이벤트 핸들러의 호출도 방지


### 15.2.6 커스텀 이벤트 전달
자바스크립트 객체는 이벤트 대상이므로 `dispatchEvent()`도 가지고 있다.
(...)


## 15.3 문서 스크립트